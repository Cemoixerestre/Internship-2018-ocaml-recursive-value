\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{mathpartir}
% \usepackage[french]{babel}

\lstset{language=caml}

% Some macros:
\newcommand{\tfun}[2]{\mathtt{fun}~#1 \to #2}
\newcommand{\tapply}[2]{#1~#2}

\newcommand{\Deref}{\mathsf{Deref}}
\newcommand{\Unguarded}{\mathsf{Unguarded}}
\newcommand{\Guarded}{\mathsf{Guarded}}
\newcommand{\Delayed}{\mathsf{Delayed}}
\newcommand{\Unused}{\mathsf{Unused}}

\newcommand{\inspect}{\mathsf{inspect}}
\newcommand{\guard}{\mathsf{guard}}
\newcommand{\discard}{\mathsf{discard}}
\newcommand{\delay}{\mathsf{delay}}
% \newcommand{\mode}[1]{\text{\textbf{#1}}}

\title{Rethinking OCaml Recursive Values}
% Should I include a kind of subtitle to indicate that this is a "rapport de
% stage" for my licence?

% [Gabriel]: you can add "Internship report:" to the title
\author{Alban Reynaud}
\date{}

\begin{document}

\maketitle

This work has been done in an internship in Inria Saclay, team Parsifal. It was
supervised by Gabriel Scherer.

% [Gabriel] You should give the specific dates of your internship, to
% situate the work in time.

\section{Introduction}
OCaml is a
% [Gabriel] statically-typed functional programming
language of the ML family. One of the features of the language is the
\lstinline|let rec| operator. It is usually used to define recursive
functions, but it can also be used to define recursive values.

For example, the following code: \lstinline|rec x = 1 :: x|
% [Gabriel] For full code examples, even short ones, you could use
% a full inline block (you don't have page limits!). Also, "rec" =>
% "let rec"
creates an infinite list containing only ones.

However, not all definitions can be computed. For example, definitions like:
\lstinline|let rec x = x + 1| should be rejected by the compiler.
% [Gabriel] again, you can use a full block for this
% [Gabriel] Why should this be rejected by the compiler?

Previously, this check relied on \textit{ad hoc} rules \cite{PreviousRules},
which caused several issues. In 2016, Jeremy Yallop proposed a new check,
designed as a simplified typing system \cite{Yallop}. One of the problem is that
his system is too complex, and it is hard to reason about.

During this internship, I investigated the current system and (following the
intuition of Gabriel Scherer) and rewrote it as an inference rules system. Then,
I designed a simpler system. I implemented it in the compiler and successfully
managed to pass the testsuite. Also, examining Jeremy Yallop's code, Gabriel and
I found a bug and sent a pull request
% [Gabriel] to fix it
.

\section{The current system}
% [Gabriel] Repeat that this is Jeremy Yallop's system

\subsection{Access modes}
Three \textit{access modes} are used in this system. These modes are:
\begin{description}
  \item[Deref] : the value of a variable is accessed.
  \item[Guarded] : the address of a variable is either placed in a constructor,
    either in an expression that is lazily evaluated, either unused.
  \item[Unguarded] : the address of a variable is not used in a guarded
    context.
\end{description}

For example:
\begin{itemize}
  \item In the expression \lstinline|x + 1|, \lstinline|x| is accessed in the
    $\Deref$ mode because its value must be accessed before being used as
    a function argument.
  \item In the expression \lstinline|1 :: x|, \lstinline|x| is accessed in the
    $\Guarded$ mode. The address of \lstinline|x| is used in the
    construction of the list, be it does not require the evaluation of
    \lstinline|x|.
  \item In the expression \lstinline|fun () -> x|, \lstinline|x| is accessed in
    the $\Guarded$ mode, because the body of this function is lazily
    evaluated, so it does not require the evaluation of \lstinline|x|.
  \item Considere the expression \lstinline |let rec x = let y = x in ...|
    In the definition of \lstinline|y|, \lstinline|x| is neither evaluater, nor
    placed in a constructor, nor lazily evaluated. \lstinline|x| is considered
    being used in the $\Unguarded$ mode.
\end{itemize}
% [Gabriel] It is bad to have two formulas or two code blocks
% separated by just a comma. You should have words of informal text
% between the two, to make parsing easier. Instead of "|code|, |x|",
% you can write "|code|, the variable |x|".

\subsection{Types and Environments}
In this system, types are maps that associate variables an access mode.
% [Gabriel] that associate an access mode to each variable
Intuitively, the type of an expression gives the use of variables in the
definition of the expression.

% [Gabriel] In the paragraph above you should give the metavariable
% for types: "types $t$ are maps ...". I don't like the use of $t$ for
% this, because it is very common to use it for expressions (terms)
% instead of types. You could use a capital $T$, or $A, B...$, or
% either $u$ or $U$ like "use".

An environment is a map that associate variables to a type.

\subsection{Operations}
Some operations are defined on modes:
\begin{displaymath}
  \begin{array}{lll}
    \guard(\Unguarded)              & = & \Guarded \\
    \guard(m \neq \Unguarded)       & = & m        \\
    \inspect(m)                     & = & \Deref   \\
    \delay(m)                       & = & \Guarded \\
    \discard(m)                     & = & \guard(m)
  \end{array}
\end{displaymath}

These operations are generalized on types.
% Should I describe more precesily what I mean, or is it clear?

% [Gabriel] "precesily" is a typo that would have caught by
% a spellchecker. You should find out how to run a spellcheck from
% your favorite text editor, and run it from times to times. In Emacs
% I use "M-x ispell".

It is possible to define an total order on modes:
$$\Deref > \Unguarded > \Guarded$$
We have $m > m'$ if the mode $m$ is more constraining than the mode $m'$.

So, let $m + m'$ denote the maximal mode between $m$ and $m'$, with respect to
this order relation. Note that this operation is called \textit{prec} in
Jeremy Yallop's code.

We can generalize this definition for types and environments:
\begin{displaymath}
  \begin{array}{lll}
    (t + t')           & : x \rightarrow & t(x) + t'(x) \\
    (\Gamma + \Gamma') & : x \rightarrow & \Gamma(x) + \Gamma'(x)
  \end{array}
\end{displaymath}

with:

\begin{displaymath}
  \begin{array}{lll}
    t(x) = \Guarded       & \text{if} & x \notin dom(t) \\
    \Gamma(x) = \emptyset & \text{if} & x \notin dom(\Gamma)
  \end{array}
\end{displaymath}

\subsection{Inference Rules}
Originally, Jeremy Yallop just gave an implementation of this
check. Gabriel Scherer proposed a first draft of inference rules
corresponding to this implementation \cite{GascheComment1, GascheComment2}.
% [Gabriel] I reformulated above. I think that Jeremy knew well that
% one could use inference rules, he just didn't bother writing them
% down in his PR.

This system works as follow: conclusions have the form
$$\Gamma \vdash e: t$$
where $\Gamma$ is an environment, $e$ is an expression and $t$ a type. The
environment is the input and the type is the ouput.

The main rules are:
\begin{mathpar}
  % [Gabriel] In {mathpar}, blank lines matter. "\\" and "\n \\ \n" do
  % not have the same semantics. You should have either \\ or a blank
  % line between two rules, but not both. If you want to skip a line
  % without using a blank line, just put a comment marker at the
  % beginning. (I did it for you below)
% 
  \infer*
    {c~\text{is a constant}}
    {\Gamma \vdash c: \emptyset}
    % [Gabriel] I believe that this rule can be skipped. It is
    % informal ("is a constant?") and not interesting.
%
  \\
%
  \infer*{ }
         {\Gamma, x: t \vdash x: t}

  \infer*%[rightstyle=\em, right={when $x \notin \Gamma$}]
    {x \notin \Gamma}
    {\Gamma \vdash x: \emptyset}
%
  \\
%
  \infer*{\Gamma \vdash e_1: t_1 \\
          \Gamma \vdash e_2: t_2}
         {\Gamma \vdash \tapply{e_1}{e_2}: \inspect(t_1 + t_2)}

  \infer*{\Gamma \vdash e: t}
         {\Gamma \vdash \tfun x e: \delay(t)}
%
  \\
%
  \infer*
    {(\Gamma \vdash e_i: t_i)^i}
    {\Gamma \vdash K(e_1, ..., e_n): \guard(t_1 + ... + t_n)}
%
  \\
\end{mathpar}
% Should I give a short explanation?

% [Gabriel]: yes, you should give a short informal explanation, of at
% least one of the rules (no need to paraphrase all of them).

% [Gabriel]: you should have the "let" rule as well, it is an
% important and delicate rule.

\subsection{The Check Algorithm}

% [Gabriel]: this should come before "The main rules are:" above. We
% need to understand how the inference rules are used by the whole
% algorithm to get an accept/reject decision, before we can read and
% appreciate the inference rules themselves.

The check is performed recursively. Every node of the abstract syntax tree
\footnote{defined in the module \texttt{Typedtree}, that is defined is the
files \texttt{typing/typedtree.mli} and \texttt{typing/typedtree.ml}} is
checked. If it is a node with the form:
\begin{lstlisting}[mathescape=true]
  let rec $x_1$ = $e_1$ and ... and $x_n$ = $e_n$
\end{lstlisting}
An environment $\Gamma = (x_i: (x_i: \Unguarded))^i$ is created.
Then, the types of the $e_i$ expressions are computed in the $\Gamma$
environment. If a variable is used in mode $\Unguarded$ or $\Deref$ in one of
these types, then the compiler reject this expression.

%[Gabriel]: the expressoins $e_i$ .. the environment $\Gamma$.

\subsection{Examples}
\textit{TODO}

\subsection{Bug in the implementation}
When examining the code, Gabriel and I found a bug. It appears in the recursive
class declarations check.

Indeed, it is possible to define classes with the syntax:
\begin{lstlisting}[mathescape=true]
class $a$ = let rec $x_1$ = $e_1$ and ... and $x_n$ = $e_n$ in $e$
\end{lstlisting}
The compiler check that the \lstinline|let rec| bindings are correct. In
particular, it is not allowed to use the recursively defined class $a$ in an
unguarded mode.

% [Gabriel]: the explanation here is wrong, and I don't know whether
% it is on purpose (a simplification) or not. The problem is not the
% `let rec`, we don't need `rec` to create bad examples (and I think
% it would be clearer if you did *not* use `rec` in this sectoin), it
% is about using the class with `new` from within the class definition:
%
% class a =
%   let x = ... new a ... in
%   object ... end

%TODO: give more details. Show the rules? The code?
The problem was that in the previous check, the expressions affected to
variables bound in the \lstinline|let rec| and the class expression $e$ were
typed separately. For example, in the definition:
\begin{lstlisting}[mathescape=true]
class a = let rec x = $e_x$ in let y = $e_y$ in $e$
\end{lstlisting}
it is possible to make an incorrect use of the variable $x$ in the expression
$e_y$.

Gabriel found that the definition:
\begin{lstlisting}
class a = let rec x = new a in let _y = x () in object end
\end{lstlisting}
caused a segfault.
% [Gabriel]: let x () = new a in ...

I wrote a patch that fix this bug, added new test and sent a pull request,
with the help of Gabriel \cite{PullRequest}.

% Note that this bug only appears since the version 4.06.

\section{A new system}

% TODO: give an short introduction, with motivations, and cite comments of
% Gabriel about this system.

\subsection{Modes, types and environments}
In Jeremy's system, access modes refer to way variables are used in expressions.
In this new system, modes are also used to describe the context in which
expressions are defined and evaluated.

Also, a problem of Jeremy's system is that the $\Guarded$ mode has a lot of
different meanings. To be more expressive, this mode is split into three modes
in this system: $\Guarded$, $\Delayed$ and $\Unused$. So we now five modes:

\begin{description}
  \item[Deref]: it refer to an expression that is evaluated and inspected, or to
    a variable such that its value is inspected.
  \item[Guarded]: it refer to a variable such that its address is used in some
    datastructure (for example: a constructor) but the variable has not been
    inspected. It also refer to an expression such that its address will used
    in such a context.
  \item[Delayed]: it refer to an expression such that its evaluation is delayed,
    or in a variable only used in delayed expressions.
  \item[Unused]: it refer to an unused variable.
  \item[Unguarded]: it refer to a variable such that its value is not inspected,
    and that its address is directly placed in a variable, not placed in some
    datastructure.
\end{description}

For example:
\begin{itemize}
  \item In the expression \lstinline|x + (y * z)|, both the variable
    \lstinline|x| and the expression \lstinline|y * z| are used in the $\Deref$
    mode.
  \item In the expression \lstinline|(f x) :: y|, both the variable
    \lstinline|y| and the expression \lstinline|f x| are used in the $\Guarded$
    mode.
  \item In the expression \lstinline|fun () -> x|, since the variable
    \lstinline|x| is inspected just when this function is called, the variable
    \lstinline|x| is used in the $\Delayed$ mode.
  \item In the expression \lstinline|fun x -> y + z|, as \lstinline|x| does not
    appear in the expression \lstinline|y + z|, \lstinline|x| is used in the
    mode $\Unused$ in the last expression.
  \item In the expression \lstinline|let y = x in y|, as the locally defined
    variable \lstinline|y| use the value \lstinline|x| but does not require the
    inspection of \lstinline|x|, as the address of \lstinline|x| is not placed
    in some datastructure, and as \lstinline|y| is returned, the variable
    \lstinline|x| is used in the $\Unguarded$ mode in the overall expression.

  % \item A more subtle example: in the expression
   % \lstinline|let rec f = fun() -> f in f| (the option \verb|-rectypes| must
    %be passed to the compiler to accept it), the address of the variable
    % \lstinline|f| is used in the environment stored in this closure.
\end{itemize}

In this system, a type is simply a mode in which an experssion is evaluated. An
environment is a map that associate to variables a mode. By default, if a
variable does appear in the domain of this map, this variable is associated to
$\Unused$.

\subsection{Relations between modes}
With these new modes, we can similarly define an order relation:
$$\Deref > \Unguarded > \Guarded > \Delayed > \Unused$$
We can define how to join two environments $\Gamma$ and $\Gamma'$ in the same
way, and use the same notation $\Gamma + \Gamma'$.

A key concept in this new system is the composition of modes. If a variable $x$
is used in an expression $e$ in mode $m$, and that this expression $e$ is used
in an expression $e'$ in mode $e'$, let $m'[m]$ denote the mode in which the
variable $x$ is used in the expression $e'$. This is called the
\textit{composition} of modes $m'$ and $m$.  We can compute the composition of two modes in this way: \begin{displaymath} \begin{array}{lll} \Deref [m]     & = & \Deref   \\
    \Delayed [m]   & = & \Delayed \\
    m[\Unguarded]  & = & m        \\
    \Unguarded [m] & = & m        \\
    \Guarded [m]   & = & m        \\
  \end{array}
\end{displaymath}
% Gabriel: You could write e[x] for e with x that occurs in it, and
% e'[e[x]] for e' with e[x] that occurs in it.

For example:
\begin{itemize}
  \item In the expression \lstinline|fun () -> x + 1|, the variable
    \lstinline|x| is used in the $\Deref$ mode in the expression
    \lstinline|x + 1|. But this expression is used in the mode $\Delayed$ in the
    expression \lstinline|fun () -> x + 1|. We can notice that the evaluation of
    x could be delayed in this function, so \lstinline|x| is used in mode
    $\Delayed$ in the overall expression. Indeed, we have
    $\Delayed [\Deref] = \Delayed$.

  \item In the expression \lstinline|Some (x + 1)|, even if the expression
    \lstinline|x + 1| is used in mode $\Guarded$, the variable \lstinline|x|
    must be inpected to evaluate both the expression \lstinline|x + 1| and the
    overall expression. Indeed, we have $\Guarded [\Deref] = \Deref$.
\end{itemize}

\subsection{Inference rules}
In this system, deduction rules have the form:
$$\Gamma \vdash e: m$$
where $\Gamma$ is a context, $e$ is an expression and $m$ is a mode.
Contrary to the previous system, the mode (or type) $m$ is the input and the
environment $\Gamma$ is the output. Intuitively, $m$ is the mode in which the
expression $e$ is evaluated, and $\Gamma$ indicates how the variables not
locally bound in $e$ must be accessed to use $e$ in the mode $m$.

The main rules are:
\begin{mathpar}
  \infer*{c~\text{is a constant}}
         {\emptyset \vdash c: m}

  \infer*{ }
         {x: m \vdash x: m}

  \\

  \infer*{\Gamma, x: \_ \vdash e: m[\Delayed]}
         {\Gamma \vdash \tfun x e : m}

  \infer*{\Gamma_1 \vdash e_1: m[\Deref] \\
          \Gamma_2 \vdash e_2: m[\Deref]}
         {\Gamma_1 + \Gamma_2 \vdash \tapply{e_1}{e_2}: m}

  \\

  \infer*{(\Gamma_i \vdash e_i: m[\Guarded])^i}
         {\Gamma_1 + ... + \Gamma_n \vdash K(e_1, ..., e_n): m}
\end{mathpar}
% [Gabriel]: you should have the "let" rule as well, it is an
% important and delicate rule.

\subsection{Implementation}
After having designed

\bibliographystyle{plain}
\bibliography{sources}

\end{document}
